#!/usr/bin/env -S qq run
########################################
#     Script for running Gromacs       #
#  flexible-length replica exchange    #
#              using qq                #
#         script version: 0.3          #
#      support: ladmeb@gmail.com       #
########################################

# qq job-type loop
# qq loop-end 9999
# qq archive storage
# qq archive-format md%04d

# strict error handling
set -euo pipefail
set -o errtrace

# if glob does not match anything, produce zero iterations
shopt -s nullglob

########################################
#           Gromacs options            #
########################################

# simulation parameters
MDP="md.mdp"
# structure file
GRO="system.gro"
# checkpoint file (e.g. from equilibration); leave empty if not needed
CPT=""
# reference coordinates for restraints; leave empty if not needed
REF=""
# index file; leave empty to set default (index.ndx)
NDX=""
# topology file; leave empty to set default (topol.top)
TOP=""
# name of the plumed script; leave empty if not used
# plumed is required if HREX is true
# plumed can be used only if the module version enables it
PLUMED=""

# pattern for simulation directory names
# with this setting, each individual simulation should be stored in a subdirectory
# following the naming pattern: win01, win02, win03, ..., win44, etc.
CLIENTS_PATTERN="win"
# frequency of replica exchange attempts; leave empty for no exchanges being attempted
RE_FREQ="50000"
# run Hamiltonian replica exchange; leave empty to NOT run Hamiltonian replica exchange
# if this option is set, you also need to set RE_FREQ
HREX="true"

# maximum number of warnings; leave empty to determine automatically (gen-vel)
MAXWARN=""

# number of MPI ranks to use; leave empty to determine automatically
MPI=""
# number of OpenMP threads per MPI rank to use; leave empty to determine automatically
NTOMP=""

# maximum duration of a simulation run (in hours); leave empty to determine automatically
MAX_TIME=""

# load gromacs module
# Infinity example
module add gromacs:2021.4-plumed

# Karolina module example
# ml GROMACS/2021.4-fosscuda-2020b-PLUMED-2.7.3

########################################
#          Execution section           #
########################################

# all client directories
CLIENTS=($(ls -d ${CLIENTS_PATTERN}* | sort -V))
# number of clients
N_CLIENTS="${#CLIENTS[@]}"
# suffixes used for the clients
CLI_SUFFIXES=()
for CLIENT in "${CLIENTS[@]}"; do
    CLI_SUFFIXES+=( "${CLIENT#${CLIENTS_PATTERN}}" )
done

# set MPI ranks and OpenMP threads
# by default, use one MPI rank per client or GPU
if [[ -z "${MPI}" ]]; then 
    MPI=$(( QQ_NGPUS > N_CLIENTS ? QQ_NGPUS : N_CLIENTS ))
    echo "[QQ_FLEX_RE]    INFO    Setting the number of MPI ranks to ${MPI}."
fi

if [[ "${MPI}" -eq 0 ]]; then
    echo "[QQ_FLEX_RE]    ERROR    The number of MPI ranks cannot be 0." >&2
    exit 1
fi

# by default, use the highest possible number of OpenMP threads
if [[ -z "${NTOMP}" ]]; then
    NTOMP=$(( QQ_NCPUS / MPI ))
    echo "[QQ_FLEX_RE]    INFO    Setting the number of OpenMP threads per MPI rank to ${NTOMP}."
fi

if [[ "${NTOMP}" -eq 0 ]]; then
    echo "[QQ_FLEX_RE]    ERROR    The number of OpenMP threads per MPI rank cannot be 0." >&2
    exit 1
fi

TOTAL_NTOMP=$(( NTOMP * MPI ))

# check for oversubscription
if [[ "${TOTAL_NTOMP}" -gt "${QQ_NCPUS}" ]]; then
    echo "[QQ_FLEX_RE]    ERROR    The total number of OpenMP threads (${TOTAL_NTOMP}) exceeds the number of allocated CPU cores (${QQ_NCPUS})." >&2
    exit 1
fi

# set OpenMP parameters
export OMP_PLACES="cores"
export OMP_NUM_THREADS="${NTOMP}"

# set communication methods for a single-node run
if [[ "${QQ_NNODES}" -eq 1 ]]; then
    export OMPI_MCA_btl="vader,self"
    export UCX_TLS="posix,self"
fi

# Gromacs -nb option
if [[ "${QQ_NGPUS}" -eq 0 ]]; then
    NB="cpu"
else
    NB="gpu"
fi

# replica exchange options
REPLEX=""
if [[ -n "${RE_FREQ}" ]]; then
    # run replica exchange
    REPLEX="-replex ${RE_FREQ}"
    if [[ -n "${HREX}" ]]; then
        # run Hamiltonian replica exchange
        HREX="-hrex"
    fi
fi

if [[ -z "${MAX_TIME}" ]]; then
    # maximum run time is automatically set to 95% of the job's walltime
    MAX_TIME=$(echo "scale=3; (${QQ_WALLTIME} * 0.95) / 1" | bc)
fi
echo "[QQ_FLEX_RE]    INFO    Setting the maximum Gromacs runtime to ${MAX_TIME} hours."

# create STAGE strings
# CURR - prefix for the data produced in this run
# NEXT - prefix for the checkpoint file for the next run
printf -v CURR "${QQ_ARCHIVE_FORMAT}" "${QQ_LOOP_CURRENT}"
printf -v NEXT "${QQ_ARCHIVE_FORMAT}" "$((QQ_LOOP_CURRENT + 1))"

# determine gromacs version to set the appropriate appending method
GMX_VER="$(gmx_mpi --version | awk 'BEGIN {i = 0} tolower($0) ~ /gromacs version/ {split($NF, N, "."); if (N[1] > 6) i = 1} END {print i}')"

# set version specific appending
APPEND=""
if [[ "${GMX_VER}" -eq 0 ]]; then
  APPEND="-append"
fi

# plumed setup
# this assumes that a consistent plumed file is used for all clients
PLUMED_FILES=""
PLUMED_METAD=""
PLUMED_METAD_LC=""
PLUMED_OUT=()
if [[ -n "${PLUMED}" ]]; then
    # obtain the names of all plumed output files
    PLUMED_TMP="$(awk '
    BEGIN {hill = ""}

    /METAD \.\.\./ {a = 1; hill = "HILLS"; next}
    /\.\.\. METAD/ {a = 0; next}
    /METAD/ {hill = "HILLS"; b = 1}

    {
        for (i = 1; i <= NF; i++) {
            if ($i ~ /^FILE/) {
                n = split($i, name, "=")
                if (a == 1 || b == 1)  { hill = name[n] }
                else { out[++o] = name[n] }
            }
        }
        b = 0
    }

    END {
        for (key in out) printf " %s", out[key]
        printf ":%s", hill
    }
    ' "${CLIENTS[0]}/${PLUMED}")"

    # plumed file names
    PLUMED_FILES="$(cut -d: -f1 <<< "${PLUMED_TMP}")"
    PLUMED_METAD="$(cut -d: -f2 <<< "${PLUMED_TMP}")"
    PLUMED_METAD_LC="$(tr '[:upper:]' '[:lower:]' <<< "${PLUMED_METAD}")"

    # plumed variable for mdrun
    PLUMED="-plumed ${PLUMED}"
elif [[ -n "${HREX}" ]]; then
    # running Hamiltonian replica exchange, using default plumed file
    PLUMED="-plumed plumed.dat"
fi

CPI=""
# used if this is the first cycle
if [[ "${QQ_LOOP_CURRENT}" -eq "${QQ_LOOP_START}" ]]; then
    # optional checkpoint and reference files for grompp
    if [[ -n "${REF}" ]]; then REF="-r ${REF}"; fi
    if [[ -n "${CPT}" ]]; then CPT="-t ${CPT}"; fi

    # default index and topology files for grompp
    if [[ -z "${NDX}" ]]; then NDX="index.ndx"; fi
    if [[ -z "${TOP}" ]]; then TOP="topol.top"; fi

    # automatically determine maxwarn based on generating velocities
    # assumed this is the same for all clients
    if [[ -z "${MAXWARN}" ]]; then
        GEN_VEL="$(awk 'BEGIN {i = 0} /gen[-_]vel/ {if (toupper($3) == "YES") i = 1} END {print i}' "${CLIENTS[0]}/${MDP}")"
        if [[ "${GEN_VEL}" -eq 0 ]]; then MAXWARN=0; else MAXWARN=1; fi
    fi

    # compile tpr files for the individual clients
    for ((I=0; I<${#CLIENTS[@]}; I++)); do
        CLI=${CLIENTS[I]}
        SUFFIX=${CLI_SUFFIXES[I]}

        cd -- "${CLI}"

        gmx_mpi grompp -f "${MDP}" -c "${GRO}" ${REF} ${CPT} -p "${TOP}" -n "${NDX}" -o "${CURR}.tpr" -quiet -maxwarn "${MAXWARN}"

        # prepare a plumed file, if it does not exist and is needed
        if [[ -n "${HREX}" ]]; then
            touch plumed.dat
        fi

        # prepare mdout for archival
        mv mdout.mdp "${CURR}.mdout"

        cd ..
    done

    # set version specific appending
    if [[ "${GMX_VER}" -eq 1 ]]; then APPEND=""; fi

# used if this is not a first cycle
else
    # mdrun checkpoint file
    CPI="-cpi ${CURR}.cpt"

    # distribute files among all clients
    for ((I=0; I<${#CLIENTS[@]}; I++)); do
        CLI=${CLIENTS[I]}
        SUFFIX=${CLI_SUFFIXES[I]}

        mv -- ${CURR}-${SUFFIX}.cpt ${CLI}/${CURR}.cpt
        mv -- ${CURR}-${SUFFIX}.tpr ${CLI}/${CURR}.tpr

        # put HILL file to the given client
        if [[ -n "${PLUMED_METAD}" ]]; then mv -- "${CURR}-${SUFFIX}.${PLUMED_METAD_LC}" "${CLI}/${CURR}.${PLUMED_METAD_LC}"; fi
    done

    # set version specific appending
    if [[ "${GMX_VER}" -eq 1 ]]; then APPEND="-noappend"; fi
fi

IFS=" "
# run the simulation
if [[ "${QQ_BATCH_SYSTEM}" == *"Slurm"* ]]; then
    srun \
    --ntasks=${MPI} \
    --cpus-per-task=${NTOMP} \
    gmx_mpi mdrun -v -deffnm ${CURR} ${CPI} \
    -cpo ${NEXT} -cpt 1 -pf ${CURR}_pf.xvg -px ${CURR}_px.xvg \
    ${PLUMED} -ntomp ${NTOMP} ${APPEND} -nb ${NB} \
    -multidir ${CLIENTS[*]} ${REPLEX} ${HREX} -maxh ${MAX_TIME}
else
    mpirun \
    -display-allocation \
    -display-map \
    -rank-by slot \
    -map-by slot:PE=${NTOMP} \
    -bind-to core \
    -np ${MPI} \
    gmx_mpi mdrun -v -deffnm ${CURR} ${CPI} \
    -cpo ${NEXT} -cpt 1 -pf ${CURR}_pf.xvg -px ${CURR}_px.xvg \
    ${PLUMED} -ntomp ${NTOMP} ${APPEND} -nb ${NB} \
    -multidir ${CLIENTS[*]} ${REPLEX} ${HREX} -maxh ${MAX_TIME}
fi

# prepare files from the clients for archival
for ((I=0; I<${#CLIENTS[@]}; I++)); do
    CLI=${CLIENTS[I]}
    SUFFIX=${CLI_SUFFIXES[I]}

    cd ${CLI}
        
    # rename output files from gromacs 2016 and later
    for PART in *part*; do
        [[ -e "${PART}" ]] || break
        IFS='.' read -r -a ARR <<< "${PART}"
        mv -- "${PART}" "${ARR[0]}.${ARR[2]}"
    done

    # rename output files from plumed
    for I in ${PLUMED_FILES}; do
        OUT="${CURR}.$(tr '[:upper:]' '[:lower:]' <<< "${I}")"
        mv -- "${I}" "${OUT}"
        PLUMED_OUT+=("${OUT}")
    done

    # rename hills files from plumed metadynamics
    if [[ -n "${PLUMED_METAD}" ]]; then
        PLUMED_HILL="${NEXT}.${PLUMED_METAD_LC}"
        mv -- "${PLUMED_METAD}" "${PLUMED_HILL}"
    fi

    # prepare the tpr file for the next run
    cp ${CURR}.tpr ${NEXT}.tpr

    # remove the unneeded _prev files
    rm -f -- *_prev*

    # prepare files for archival
    for FILE in *${CURR}* *${NEXT}*; do
        STEM="${FILE%%.*}"
        EXT="${FILE#*.}"

        mv -- "${FILE}" "../${STEM}-${SUFFIX}.${EXT}"
    done

    cd ..
done

# extend the simulation
LAST_STEP=$(awk '$1 ~ /step$/ {step = $2} END {print step}' $(ls -tr1 *.err | tail -1) | sed 's/[^0-9]*//g')
TARGET_STEP=$(gmx_mpi dump -s ${CURR}-${CLI_SUFFIXES[0]}.tpr 2> /dev/null | awk '/nsteps/ {print $3}')

echo "[QQ_FLEX_RE]    INFO    Last step: ${LAST_STEP} and target step: ${TARGET_STEP}"
if [[ "${LAST_STEP}" -ge "${TARGET_STEP}" ]]; then
    # signal to qq that the job should not be resubmitted
    exit "${QQ_NO_RESUBMIT}"
fi